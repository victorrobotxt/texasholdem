--- GLASHAUS PROJECT DUMP ---
Fri Feb  6 02:45:04 PM EET 2026


--- GIT HISTORY ---
* e6b2487 (HEAD -> main, origin/main, origin/HEAD) clean up directory
* cc5857e docs: Final project documentation and environment cleanup
* a685ee1 chore(backend): Update Gemini model to gemini-flash-latest for efficiency
* 590ce39 feat(frontend): Implement final UI visual polish and theme
* 7ee9cfc docs: Add integration scripts and update documentation
* 862bcd9 tests: Add comprehensive logic verification
* 3c2c8bc ai: Integrate Gemini AI player with background threads
* 589ee95 ui: Add ActionControls with animation
* 99ab31b frontend: Integrate SocketIO hooks and GameState
* e971553 frontend: Implement GameBoard and Player layout
* 91c6380 ui: Create core visual components (Card, Chips)
* 787fa33 frontend: Initialize React structure and configs
* 9ad70f4 api: Setup Flask server with SocketIO support
* dc8a77f backend: Implement GameEngine state machine with type hints
* 40e35ff backend: Implement hand evaluation logic
* 6ff86c7 backend: Define Card and Deck models (Dataclasses)
* 0294d47 chore: Initial project structure and gitignore


--- FILE STRUCTURE ---
.
├── context_dump.sh
├── docker-compose.yml
├── glashaus_context.txt
├── test_backend_integration.sh
├── texas-holdem-backend
│   ├── ai
│   │   ├── gemini_player.py
│   │   └── __init__.py
│   ├── app.py
│   ├── Dockerfile
│   ├── game
│   │   ├── card.py
│   │   ├── deck.py
│   │   ├── engine.py
│   │   ├── hand_evaluator.py
│   │   ├── __init__.py
│   │   └── player.py
│   ├── README.md
│   ├── requirements.txt
│   └── tests
│       ├── __init__.py
│       ├── test_api.py
│       ├── test_deck.py
│       ├── test_engine.py
│       ├── test_hand_evaluator.py
│       ├── test_player.py
│       └── test_poker_logic.py
└── texas-holdem-frontend
    ├── App.tsx
    ├── components
    │   ├── ActionControls.tsx
    │   ├── Card.tsx
    │   ├── ChipPile.tsx
    │   ├── GameBoard.tsx
    │   ├── HandStrength.tsx
    │   ├── Player.tsx
    │   └── WinnerOverlay.tsx
    ├── Dockerfile
    ├── hooks
    │   └── useGameEngine.ts
    ├── index.css
    ├── index.html
    ├── index.tsx
    ├── metadata.json
    ├── node_modules
    │   ├── @babel
    │   ├── baseline-browser-mapping
    │   ├── browserslist
    │   ├── caniuse-lite
    │   ├── convert-source-map
    │   ├── debug
    │   ├── electron-to-chromium
    │   ├── engine.io-client
    │   ├── engine.io-parser
    │   ├── @esbuild
    │   ├── esbuild
    │   ├── escalade
    │   ├── fdir
    │   ├── framer-motion
    │   ├── gensync
    │   ├── @jridgewell
    │   ├── jsesc
    │   ├── json5
    │   ├── js-tokens
    │   ├── lru-cache
    │   ├── motion-dom
    │   ├── motion-utils
    │   ├── ms
    │   ├── nanoid
    │   ├── node-releases
    │   ├── picocolors
    │   ├── picomatch
    │   ├── postcss
    │   ├── react
    │   ├── react-dom
    │   ├── react-refresh
    │   ├── @rolldown
    │   ├── @rollup
    │   ├── rollup
    │   ├── scheduler
    │   ├── semver
    │   ├── @socket.io
    │   ├── socket.io-client
    │   ├── socket.io-parser
    │   ├── source-map-js
    │   ├── tinyglobby
    │   ├── tslib
    │   ├── @types
    │   ├── typescript
    │   ├── undici-types
    │   ├── update-browserslist-db
    │   ├── vite
    │   ├── @vitejs
    │   ├── ws
    │   ├── xmlhttprequest-ssl
    │   └── yallist
    ├── package.json
    ├── README.md
    ├── styles
    │   └── GameBoard.css
    ├── tsconfig.json
    ├── types.ts
    └── vite.config.ts

61 directories, 43 files


--- FILE CONTENTS ---


=========================================
FILE: ./.github/workflows/ci.yml
=========================================
name: Python Backend CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ./texas-holdem-backend

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Set up Python 3.9
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests with pytest
      env:
        GOOGLE_API_KEY: "dummy_key_for_ci"
      run: |
        pytest


=========================================
FILE: ./.gitignore
=========================================
# Python virtual environment
.venv/
venv/
__pycache__/

# Helper scripts and generated files at root level
/copyDir.py
/forge_git_history.sh
/output.txt
/stripped.json
/metadata.json

# IDE and OS files
.vscode/
.idea/
.DS_Store

# Frontend build/dependency folders
node_modules/
dist/

# Secret files - never commit these
texas-holdem-backend/.env
texas-holdem-frontend/.env.local
res.txt
texas-holdem-backend/res.txt
.env


=========================================
FILE: ./test_backend_integration.sh
=========================================
#!/bin/bash
#
# Integration test script for the Texas Hold'em backend.
# This script uses curl to interact with the API endpoints.
#
# Prerequisite: The Flask server (app.py) must be running.
#   - python texas-holdem-backend/app.py

# --- Configuration ---
BASE_URL="http://localhost:5001/api"
PLAYER_NAME="CURL_Matador"

# --- Colors and Helpers ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

print_test() {
    echo -e "\n${YELLOW}--- TESTING: $1 ---${NC}"
}

check_success() {
    if [ "$1" -eq "$2" ]; then
        echo -e "${GREEN}PASS: Expected HTTP $2, got $1.${NC}"
        PASS_COUNT=$((PASS_COUNT + 1))
    else
        echo -e "${RED}FAIL: Expected HTTP $2, got $1.${NC}"
        FAIL_COUNT=$((FAIL_COUNT + 1))
    fi
}

check_error_contains() {
    # $1: response body, $2: expected substring
    if echo "$1" | grep -q "$2"; then
        echo -e "${GREEN}PASS: Error message contains expected text ('$2').${NC}"
        PASS_COUNT=$((PASS_COUNT + 1))
    else
        echo -e "${RED}FAIL: Error message did not contain expected text ('$2').${NC}"
        echo "Full response: $1"
        FAIL_COUNT=$((FAIL_COUNT + 1))
    fi
}

# --- Test Execution ---
PASS_COUNT=0
FAIL_COUNT=0

# Ensure jq is installed
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: 'jq' is not installed. Please install it to run this script (e.g., 'sudo apt-get install jq' or 'brew install jq').${NC}"
    exit 1
fi

echo "Starting backend integration tests..."

# 1. Create a New Game
print_test "Create a New Game (POST /api/game)"
CREATE_RESPONSE=$(curl -s -X POST \
  -H "Content-Type: application/json" \
  -d "{\"playerName\": \"$PLAYER_NAME\"}" \
  "$BASE_URL/game")
  
HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" -d "{\"playerName\": \"$PLAYER_NAME\"}" "$BASE_URL/game")
check_success "$HTTP_STATUS" 200

GAME_ID=$(echo "$CREATE_RESPONSE" | jq -r '.gameId')
if [ "$GAME_ID" != "null" ] && [ ! -z "$GAME_ID" ]; then
    echo -e "${GREEN}PASS: Successfully created game with ID: $GAME_ID${NC}"
    PASS_COUNT=$((PASS_COUNT + 1))
else
    echo -e "${RED}FAIL: Could not extract gameId from response.${NC}"
    echo "Full response: $CREATE_RESPONSE"
    FAIL_COUNT=$((FAIL_COUNT + 1))
    exit 1 # Cannot continue without a game ID
fi


# 2. Get Game State
print_test "Get Game State (GET /api/game/$GAME_ID)"
HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/game/$GAME_ID")
check_success "$HTTP_STATUS" 200


# 3. Submit an Invalid Action Payload
print_test "Submit Invalid Action Payload (POST /api/game/$GAME_ID/action)"
RESPONSE_BODY=$(curl -s -w "\n%{http_code}" -X POST \
    -H "Content-Type: application/json" \
    -d '{"playerID": 0, "move": "fold"}' \
    "$BASE_URL/game/$GAME_ID/action")
HTTP_STATUS=$(echo "$RESPONSE_BODY" | tail -n1)
BODY=$(echo "$RESPONSE_BODY" | sed '$d')
check_success "$HTTP_STATUS" 400
check_error_contains "$BODY" "Invalid request payload"


# 4. Attempt to Act Out of Turn
# In a new game, player 0 (human) is not first to act.
print_test "Attempt to Act Out of Turn (POST /api/game/$GAME_ID/action)"
RESPONSE_BODY=$(curl -s -w "\n%{http_code}" -X POST \
    -H "Content-Type: application/json" \
    -d '{"playerId": 0, "action": "call", "amount": 0}' \
    "$BASE_URL/game/$GAME_ID/action")
HTTP_STATUS=$(echo "$RESPONSE_BODY" | tail -n1)
BODY=$(echo "$RESPONSE_BODY" | sed '$d')
check_success "$HTTP_STATUS" 400
check_error_contains "$BODY" "Not this player's turn"


# 5. Get State for a Non-Existent Game
print_test "Get State for a Non-Existent Game (GET /api/game/fake-id)"
HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/game/fake-id")
check_success "$HTTP_STATUS" 404

# --- Summary ---
echo -e "\n--- Test Summary ---"
echo -e "${GREEN}Passed: $PASS_COUNT${NC}"
echo -e "${RED}Failed: $FAIL_COUNT${NC}"

if [ "$FAIL_COUNT" -gt 0 ]; then
    exit 1
else
    echo -e "${GREEN}All integration tests passed successfully.${NC}"
    exit 0
fi


=========================================
FILE: ./texas-holdem-backend/.env.example
=========================================
GOOGLE_API_KEY="YOUR_GOOGLE_API_KEY_HERE"


=========================================
FILE: ./texas-holdem-backend/.gitignore
=========================================



=========================================
FILE: ./texas-holdem-backend/README.md
=========================================
# Texas Hold'em AI Backend

A Flask-SocketIO Python backend implementing the complete rules of Texas Hold'em, designed to be graded for Python code quality and architecture.

## Architecture
- **`app.py`**: Entry point, manages WebSocket connections and background threads.
- **`game/`**: Pure Python logic.
  - `engine.py`: State machine handling game stages and turn rotation.
  - `hand_evaluator.py`: Mathematical logic to determine hand strength.
  - `card.py` / `deck.py`: Core data models.
- **`ai/`**: Integration with Google Gemini for opponent logic.

## Installation

1. **Environment**:
   ```bash
   python -m venv venv
   source venv/bin/activate  # Windows: venv\Scripts\activate
   pip install -r requirements.txt
   ```

2. **Configuration**:
   Create a `.env` file:
   ```ini
   GOOGLE_API_KEY="your_key_here"
   FLASK_ENV=development
   SECRET_KEY="dev_key"
   ```

3. **Run**:
   ```bash
   python app.py
   ```

## Testing
To verify logic and code coverage:
```bash
pytest --cov=game tests/
```

=========================================
FILE: ./texas-holdem-backend/ai/__init__.py
=========================================


=========================================
FILE: ./texas-holdem-backend/ai/gemini_player.py
=========================================
import os
import json
import logging
from typing import Dict, Any
import google.generativeai as genai
from dotenv import load_dotenv
from tenacity import retry, stop_after_attempt, wait_fixed

load_dotenv()

logger = logging.getLogger('poker.ai')

# Safe initialization
API_KEY = os.getenv("GOOGLE_API_KEY")
if API_KEY:
    genai.configure(api_key=API_KEY)
    model = genai.GenerativeModel("models/gemini-flash-latest")
else:
    model = None


def _get_position_name(player_id: int, dealer_id: int, num_players: int) -> str:
    """Calculate position relative to dealer."""
    relative_pos = (player_id - dealer_id) % num_players
    if relative_pos == 1:
        return "Small Blind (early)"
    elif relative_pos == 2:
        return "Big Blind (early)"
    elif relative_pos == 3:
        return "Under the Gun (early)"
    elif relative_pos >= num_players - 1:
        return "Button (late - best position)"
    else:
        return "Middle position"


def _calculate_pot_odds(pot: int, to_call: int) -> str:
    """Calculate pot odds as a ratio."""
    if to_call <= 0:
        return "N/A (no call required)"
    total_pot = pot + to_call
    ratio = total_pot / to_call
    return f"{ratio:.1f}:1 (need {100/ratio:.0f}% equity to call)"


def _summarize_opponents(players: list, my_id: int) -> str:
    """Create a summary of opponent states."""
    lines = []
    for p in players:
        if p['id'] == my_id:
            continue
        status = "folded" if p['isFolded'] else f"${p['chips']} chips, bet ${p['currentBet']}"
        action = f" - last: {p['lastAction']}" if p.get('lastAction') else ""
        lines.append(f"  - {p['name']}: {status}{action}")
    return "\n".join(lines)


@retry(stop=stop_after_attempt(3), wait=wait_fixed(1))
def get_ai_decision(game_state: Dict[str, Any], player_id: int) -> Dict[str, Any]:
    """
    Queries Gemini API for a poker decision.
    Returns a dict with keys: action (str), amount (int).
    """
    if not model:
        return _fallback_logic(game_state, player_id)

    # Locate self
    my_player = next((p for p in game_state['players'] if p['id'] == player_id), None)
    if not my_player:
        return {"action": "fold", "amount": 0}

    to_call = game_state['betToCall'] - my_player['currentBet']
    position = _get_position_name(player_id, game_state['dealerId'], len(game_state['players']))
    pot_odds = _calculate_pot_odds(game_state['pot'], to_call)
    opponents = _summarize_opponents(game_state['players'], player_id)

    # Construct enhanced context
    prompt = f"""You are a skilled Poker AI playing Texas Hold'em. Make strategic decisions.

YOUR SITUATION:
- Name: {my_player.get('name', f'Player {player_id}')}
- Position: {position}
- Chips: ${my_player['chips']}
- Your Hand: {my_player['hand']}
- Your Current Bet: ${my_player['currentBet']}

TABLE STATE:
- Stage: {game_state['stage']}
- Community Cards: {game_state['communityCards'] or 'None yet'}
- Pot: ${game_state['pot']}
- Amount to Call: ${to_call}
- Pot Odds: {pot_odds}

OPPONENTS:
{opponents}

STRATEGY TIPS:
- Late position (Button) allows you to play more hands
- Early position requires stronger hands
- Pot odds help determine if calling is profitable
- Consider opponent tendencies based on their last actions
- Mix up your play to avoid being predictable

VALID ACTIONS:
- "fold": Give up your hand
- "check": Pass if no bet to call (to_call = 0)
- "call": Match the current bet
- "raise": Increase the bet (specify amount as total bet size)

Respond with ONLY valid JSON: {{"action": "string", "amount": integer}}
For raise, amount should be the TOTAL bet (e.g., if current bet is 20, raise to 50 means amount: 50)"""

    try:
        response = model.generate_content(prompt)
        text = response.text.strip()
        
        # Sanitization for common Markdown wrappers
        if text.startswith("```json"):
            text = text[7:-3]
        elif text.startswith("```"):
            text = text[3:-3]
        text = text.strip()

        decision = json.loads(text)

        # Validation
        if decision['action'] not in ['fold', 'check', 'call', 'bet', 'raise']:
            raise ValueError("Invalid Action")

        logger.debug(f"AI decision for player {player_id}: {decision}")
        return decision
    except Exception as e:  # pylint: disable=broad-except
        logger.warning(f"AI Error for player {player_id}: {e}")
        return _fallback_logic(game_state, player_id)


def _fallback_logic(game_state: dict, player_id: int) -> dict:
    """Simple rule-based fallback if AI fails."""
    p_list = game_state.get('players', [])
    # Find player by ID
    p = next((x for x in p_list if x['id'] == player_id), None)
    if not p:
        return {"action": "fold", "amount": 0}

    to_call = game_state['betToCall'] - p['currentBet']

    if to_call == 0:
        return {"action": "check", "amount": 0}
    if to_call < (p['chips'] / 10):
        return {"action": "call", "amount": 0}

    return {"action": "fold", "amount": 0}



=========================================
FILE: ./texas-holdem-backend/app.py
=========================================
import time
import threading
import logging
from flask import Flask, jsonify, request
from flask_socketio import SocketIO, emit, join_room
from flask_cors import CORS

from game.engine import GameEngine
from game.player import Player
from ai.gemini_player import get_ai_decision

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger('poker')

app = Flask(__name__)
app.config['SECRET_KEY'] = 'poker_secret'
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# In-memory storage
games: dict[str, GameEngine] = {}

def run_ai_cycle(game_id: str) -> None:
    """Background task to handle consecutive AI turns."""
    game = games.get(game_id)
    if not game:
        return
    
    while True:
        with game.lock:  # Thread-safe access
            if game.stage == "HAND_OVER":
                logger.info(f"[{game_id[:8]}] AI cycle ended - hand over")
                break

            current_id = game.active_player_id
            if current_id == -1:
                break

            current_player = game.players[current_id]
            if current_player.is_human:
                logger.debug(f"[{game_id[:8]}] Waiting for human player")
                break

            # Serialize state for AI (inside lock)
            state = game.to_dict(for_player_id=current_id)

        # AI decision (outside lock to avoid blocking)
        time.sleep(1.0)  # Artificial delay for realism
        move = get_ai_decision(state, current_id)
        logger.info(f"[{game_id[:8]}] AI {current_player.name}: {move['action']} {move.get('amount', '')}")

        with game.lock:  # Re-acquire for state mutation
            try:
                game.process_player_action(
                    current_id, move['action'], move.get('amount', 0)
                )
                socketio.emit('update', game.to_dict(for_player_id=0), to=game_id)
            except Exception as e:  # pylint: disable=broad-except
                logger.error(f"[{game_id[:8]}] Error processing AI {current_id}: {e}")
                game.process_player_action(current_id, "fold")
                socketio.emit('update', game.to_dict(for_player_id=0), to=game_id)

@app.route('/api/game', methods=['POST'])
def create_game():
    data = request.json or {}
    p_name = data.get('playerName', 'Human')

    human = Player(id=0, name=p_name, chips=1000, is_human=True)
    bots = [
        Player(id=1, name="Viper", chips=1000),
        Player(id=2, name="Mountain", chips=1000),
        Player(id=3, name="Shark", chips=1000)
    ]

    engine = GameEngine([human] + bots)
    games[engine.id] = engine

    # If Human is not first (e.g., BB is pos 2, UTG is 3), trigger AI
    if engine.active_player_id != 0:
        threading.Thread(target=run_ai_cycle, args=(engine.id,)).start()

    return jsonify(engine.to_dict(for_player_id=0))

@app.route('/api/game/<game_id>/next', methods=['POST'])
def next_hand(game_id):
    game = games.get(game_id)
    if not game:
        return jsonify({"error": "Not found"}), 404

    game.start_new_hand()

    if game.active_player_id != 0:
        threading.Thread(target=run_ai_cycle, args=(game.id,)).start()

    return jsonify(game.to_dict(for_player_id=0))

# --- Socket Events ---

@socketio.on('join')
def on_join(data):
    room = data.get('gameId')
    join_room(room)
    if room in games:
        emit('update', games[room].to_dict(for_player_id=0))

@socketio.on('action')
def on_action(data):
    game_id = data.get('gameId')
    game = games.get(game_id)
    if not game:
        return

    try:
        game.process_player_action(0, data['action'], data.get('amount', 0))
        emit('update', game.to_dict(for_player_id=0), to=game_id)

        # Trigger AI chain
        if game.active_player_id != 0:
            threading.Thread(target=run_ai_cycle, args=(game_id,)).start()

    except ValueError as e:
        emit('error', {'message': str(e)})

if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5001, debug=True)

=========================================
FILE: ./texas-holdem-backend/game/__init__.py
=========================================


=========================================
FILE: ./texas-holdem-backend/game/card.py
=========================================
from enum import IntEnum
from functools import total_ordering

class Suit(IntEnum):
    SPADES = 1
    HEARTS = 2
    DIAMONDS = 3
    CLUBS = 4

class Rank(IntEnum):
    TWO = 2
    THREE = 3
    FOUR = 4
    FIVE = 5
    SIX = 6
    SEVEN = 7
    EIGHT = 8
    NINE = 9
    TEN = 10
    JACK = 11
    QUEEN = 12
    KING = 13
    ACE = 14

@total_ordering
class Card:
    """Represents a standard playing card."""

    def __init__(self, rank: Rank, suit: Suit):
        self.rank = rank
        self.suit = suit

    def __repr__(self) -> str:
        return f"{self.rank.name.capitalize()} of {self.suit.name.capitalize()}"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Card):
            return NotImplemented
        return self.rank == other.rank and self.suit == other.suit

    def __lt__(self, other: object) -> bool:
        if not isinstance(other, Card):
            return NotImplemented
        return self.rank < other.rank

    def to_str(self) -> str:
        """Returns short string format, e.g. 'AS', 'TH'."""
        rank_char = str(self.rank.value)
        if self.rank.value == 10:
            rank_char = 'T'
        elif self.rank == Rank.JACK:
            rank_char = 'J'
        elif self.rank == Rank.QUEEN:
            rank_char = 'Q'
        elif self.rank == Rank.KING:
            rank_char = 'K'
        elif self.rank == Rank.ACE:
            rank_char = 'A'

        return f"{rank_char}{self.suit.name[0]}"


=========================================
FILE: ./texas-holdem-backend/game/deck.py
=========================================
import random
from typing import List, Tuple
from .card import Card, Rank, Suit

class Deck:
    def __init__(self) -> None:
        # List comprehension to build deck (Pythonic)
        self._cards: List[Card] = [
            Card(rank, suit) 
            for suit in Suit 
            for rank in Rank
        ]
        self.shuffle()

    def shuffle(self) -> None:
        random.shuffle(self._cards)

    def deal(self, amount: int = 1) -> List[Card]:
        """Deals n cards from top of deck."""
        if len(self._cards) < amount:
            raise ValueError("Not enough cards in deck")
        
        # Slicing strategy to remove and return
        dealt = self._cards[:amount]
        del self._cards[:amount]
        return dealt


=========================================
FILE: ./texas-holdem-backend/game/engine.py
=========================================
import uuid
import threading
from typing import List, Dict, Any
from .card import Card
from .deck import Deck
from .player import Player
from .hand_evaluator import evaluate_hand

class GameEngine:
    def __init__(self, players: List[Player]):
        self.id = str(uuid.uuid4())
        self.lock = threading.RLock()  # Thread-safe access to game state
        self.players = players
        self.deck = Deck()
        self.community_cards: List[Card] = []
        self.pot = 0

        # Game State Pointers
        self.dealer_pos = 0
        self.active_player_id = 0
        self.bet_to_call = 0
        self.stage = "PRE_FLOP"
        self.winners: List[int] = []

        self.start_new_hand()

    def start_new_hand(self) -> None:
        self.deck = Deck()
        self.community_cards = []
        self.pot = 0
        self.winners = []
        self.stage = "PRE_FLOP"

        # Rotate Dealer
        self.dealer_pos = (self.dealer_pos + 1) % len(self.players)

        # Reset players
        active_count = 0
        for p in self.players:
            p.reset_hand_state()
            if p.chips > 0:
                p.hand = self.deck.deal(2)
                active_count += 1
            else:
                p.is_folded = True

        if active_count < 2:
            # Game Over logic usually goes here
            pass

        # Blinds logic
        sb_pos = (self.dealer_pos + 1) % len(self.players)
        bb_pos = (self.dealer_pos + 2) % len(self.players)

        self._post_blind(sb_pos, 10)
        self._post_blind(bb_pos, 20)
        self.bet_to_call = 20

        # Set action to UTG (Under the Gun)
        self.active_player_id = (bb_pos + 1) % len(self.players)

    def _post_blind(self, player_idx: int, amount: int) -> None:
        player = self.players[player_idx]
        if player.chips > 0:
            bet = player.bet(amount)
            self.pot += bet
            player.last_action = "Blind"

    def process_player_action(self, player_id: int, action: str, amount: int = 0) -> None:
        if player_id != self.active_player_id:
            raise ValueError("Not this player's turn")

        player = self.players[player_id]

        if action == "fold":
            player.fold()

        elif action in ["check", "call"]:
            call_amt = self.bet_to_call - player.current_bet
            if call_amt > 0:
                added = player.bet(call_amt)
                self.pot += added
                player.last_action = "Call"
            else:
                player.last_action = "Check"

        elif action in ["bet", "raise"]:
            # Logic: Input 'amount' is the TARGET TOTAL bet (e.g., Raise TO 50)
            diff = amount - player.current_bet
            added = player.bet(diff)
            self.pot += added

            if player.current_bet > self.bet_to_call:
                self.bet_to_call = player.current_bet
                player.last_action = f"Raise ${player.current_bet}"
            else:
                player.last_action = "All In"

        self._rotate_turn()

    def _rotate_turn(self) -> None:
        # Check if round is complete
        active_players = [p for p in self.players if not p.is_folded and p.chips > 0]

        # 1. Everyone folded but one?
        if len([p for p in self.players if not p.is_folded]) == 1:
            self._end_hand_prematurely()
            return

        # 2. Check if everyone active has matched the bet
        all_matched = all(
            p.current_bet == self.bet_to_call or p.is_all_in for p in active_players
        )

        current_idx = self.active_player_id

        # Try finding next player in current betting round
        for i in range(1, len(self.players)):
            idx = (current_idx + i) % len(self.players)
            p = self.players[idx]

            if p.is_folded or p.is_all_in:
                continue

            # If they haven't matched the bet, it's definitely their turn
            if p.current_bet < self.bet_to_call:
                self.active_player_id = idx
                return

        if all_matched and self.active_player_id != -1:
            # Check if BIG BLIND has option in Pre-Flop
            bb_pos = (self.dealer_pos + 2) % len(self.players)
            curr_player = self.players[self.active_player_id]

            is_preflop = self.stage == "PRE_FLOP"
            is_bb = self.active_player_id == bb_pos
            no_raises = self.bet_to_call == 20
            blind_act = curr_player.last_action == "Blind"

            if is_preflop and is_bb and no_raises and blind_act:
                return

            self._advance_stage()
            return

    def _advance_stage(self) -> None:
        for p in self.players:
            p.reset_round_state()
        self.bet_to_call = 0

        if self.stage == "PRE_FLOP":
            self.stage = "FLOP"
            self.community_cards.extend(self.deck.deal(3))
        elif self.stage == "FLOP":
            self.stage = "TURN"
            self.community_cards.extend(self.deck.deal(1))
        elif self.stage == "TURN":
            self.stage = "RIVER"
            self.community_cards.extend(self.deck.deal(1))
        elif self.stage == "RIVER":
            self._resolve_showdown()
            return

        # Set active player to first after dealer
        idx = self.dealer_pos
        for i in range(1, len(self.players) + 1):
            next_idx = (idx + i) % len(self.players)
            p = self.players[next_idx]
            if not p.is_folded and not p.is_all_in:
                self.active_player_id = next_idx
                return

        # If everyone is all-in, just run to river
        if self.stage != "HAND_OVER":
            self._advance_stage()

    def _resolve_showdown(self) -> None:
        self.stage = "SHOWDOWN"
        self.active_player_id = -1

        remaining = [p for p in self.players if not p.is_folded]

        results = []
        for p in remaining:
            score_tuple = evaluate_hand(p.hand + self.community_cards)
            results.append((p, score_tuple))

        if not results:
            return

        best_score = max(results, key=lambda x: x[1])[1]
        winners = [p for p, score in results if score == best_score]

        self.winners = [p.id for p in winners]

        # Split pot
        if winners:
            share = self.pot // len(winners)
            for p in winners:
                p.chips += share

        self.stage = "HAND_OVER"

    def _end_hand_prematurely(self) -> None:
        """Everyone folded except one."""
        winner = next(p for p in self.players if not p.is_folded)
        winner.chips += self.pot
        self.winners = [winner.id]
        self.stage = "HAND_OVER"
        self.active_player_id = -1

    def to_dict(self, for_player_id: int) -> Dict[str, Any]:
        return {
            "gameId": self.id,
            "pot": self.pot,
            "communityCards": [c.to_str() for c in self.community_cards],
            "activePlayerId": self.active_player_id,
            "dealerId": self.dealer_pos,
            "smallBlindPlayerId": (self.dealer_pos + 1) % len(self.players),
            "bigBlindPlayerId": (self.dealer_pos + 2) % len(self.players),
            "stage": self.stage,
            "betToCall": self.bet_to_call,
            "winners": self.winners,
            "players": [
                p.to_dict(show_hand=(p.id == for_player_id or self.stage == "SHOWDOWN"))
                for p in self.players
            ]
        }


=========================================
FILE: ./texas-holdem-backend/game/hand_evaluator.py
=========================================
from collections import Counter
from typing import List, Tuple, Union
from .card import Card, Rank

# Rank Hierarchy: (Score, Kicker_List)
# 9: Str Flush, 8: Quads, 7: FH, 6: Flush, 5: Str, 4: Set, 3: 2Pair, 2: Pair, 1: High

def evaluate_hand(cards: List[Card]) -> Tuple[int, List[int]]:
    """
    Calculates the strength of a 5-7 card hand.
    Returns (Score, [Kickers]) for easy tuple comparison.
    """
    if not cards or len(cards) < 5:
        return (0, [])

    # Sort by rank descending
    sorted_cards = sorted(cards, key=lambda c: c.rank, reverse=True)
    
    # Check Flush
    suit_counts = Counter(c.suit for c in sorted_cards)
    flush_suit = next((s for s, c in suit_counts.items() if c >= 5), None)
    
    flush_cards = []
    if flush_suit:
        flush_cards = [c for c in sorted_cards if c.suit == flush_suit]

    # Check Straight
    def get_straight(candidates: List[Card]) -> Union[List[int], None]:
        unique_ranks = sorted(list(set(c.rank.value for c in candidates)), reverse=True)
        
        # Standard Straight
        for i in range(len(unique_ranks) - 4):
            window = unique_ranks[i:i+5]
            if window[0] - window[4] == 4:
                return window
        
        # Wheel (A-5)
        if {14, 2, 3, 4, 5}.issubset(set(unique_ranks)):
            return [5, 4, 3, 2, 14] # 5-high straight
            
        return None

    # 1. Straight Flush
    if flush_suit:
        sf_ranks = get_straight(flush_cards)
        if sf_ranks:
            return (9, sf_ranks)

    # 2. Four of a Kind
    rank_counts = Counter(c.rank.value for c in sorted_cards)
    quads = [r for r, count in rank_counts.items() if count == 4]
    if quads:
        kicker = max([r for r in rank_counts if r != quads[0]])
        return (8, [quads[0], kicker])

    # 3. Full House
    trips = [r for r, count in rank_counts.items() if count == 3]
    pairs = [r for r, count in rank_counts.items() if count == 2]
    
    if trips:
        # Best trip
        top_trip = trips[0]
        # Attempt to find a pair, or a second trip (which counts as a pair)
        remaining_trips = [t for t in trips if t != top_trip]
        all_pairs = sorted(pairs + remaining_trips, reverse=True)
        
        if all_pairs:
            return (7, [top_trip, all_pairs[0]])

    # 4. Flush
    if flush_suit:
        return (6, [c.rank.value for c in flush_cards[:5]])

    # 5. Straight
    straight_ranks = get_straight(sorted_cards)
    if straight_ranks:
        return (5, straight_ranks)

    # 6. Three of a Kind
    if trips:
        kickers = sorted([r for r in rank_counts if r != trips[0]], reverse=True)[:2]
        return (4, [trips[0]] + kickers)

    # 7. Two Pair
    if len(pairs) >= 2:
        top_pairs = pairs[:2]
        kicker = max([r for r in rank_counts if r not in top_pairs])
        return (3, top_pairs + [kicker])

    # 8. One Pair
    if pairs:
        kickers = sorted([r for r in rank_counts if r != pairs[0]], reverse=True)[:3]
        return (2, [pairs[0]] + kickers)

    # 9. High Card
    return (1, [c.rank.value for c in sorted_cards[:5]])


=========================================
FILE: ./texas-holdem-backend/game/player.py
=========================================
from dataclasses import dataclass, field
from typing import List, Optional
from .card import Card

@dataclass
class Player:
    id: int
    name: str  # FIXED: 'string' is a module, 'str' is the type
    chips: int
    is_human: bool = False
    hand: List[Card] = field(default_factory=list)
    current_bet: int = 0
    is_folded: bool = False
    is_all_in: bool = False
    last_action: Optional[str] = None

    def bet(self, amount: int) -> int:
        """
        Deducts chips and adds to current bet.
        Returns the actual amount added (handling all-in scenarios).
        """
        actual_bet = min(self.chips, amount)
        self.chips -= actual_bet
        self.current_bet += actual_bet

        if self.chips == 0:
            self.is_all_in = True

        return actual_bet

    def fold(self) -> None:
        self.is_folded = True
        self.last_action = "Fold"

    def reset_round_state(self) -> None:
        self.current_bet = 0
        self.last_action = None

    def reset_hand_state(self) -> None:
        self.hand = []
        self.current_bet = 0
        self.is_folded = False
        self.is_all_in = False
        self.last_action = None

    def to_dict(self, show_hand: bool = False) -> dict:
        """Serialization helper."""
        hand_display = []
        if show_hand:
            hand_display = [c.to_str() for c in self.hand]
        elif self.hand:
            hand_display = ["BACK", "BACK"]

        return {
            "id": self.id,
            "name": self.name,
            "chips": self.chips,
            "hand": hand_display,
            "currentBet": self.current_bet,
            "isFolded": self.is_folded,
            "isAllIn": self.is_all_in,
            "isHuman": self.is_human,
            "lastAction": self.last_action
        }


=========================================
FILE: ./texas-holdem-backend/requirements.txt
=========================================
Flask==3.0.0
Flask-SocketIO==5.3.6
Flask-Cors==4.0.0
python-dotenv==1.0.0
google-generativeai==0.3.2
pydantic==2.5.3
structlog==24.1.0
tenacity==8.2.3
eventlet==0.33.3
pytest==7.4.4
pytest-mock==3.12.0
pytest-cov==4.1.0


=========================================
FILE: ./texas-holdem-backend/tests/__init__.py
=========================================


=========================================
FILE: ./texas-holdem-backend/tests/test_api.py
=========================================
import pytest
from app import app
from unittest.mock import patch

@pytest.fixture
def client():
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

# Correct mock path to where get_ai_decision is imported in app.py
# or where it is defined. Based on app.py imports: 'ai.gemini_player.get_ai_decision'
@patch('ai.gemini_player.get_ai_decision')
def test_create_game_api(mock_get_ai, client):
    """Test game creation endpoint."""
    # Mock return must look like an AI decision
    mock_get_ai.return_value = {"action": "fold", "amount": 0}
    
    response = client.post('/api/game', json={"playerName": "Test Player"})
    assert response.status_code == 200
    
    data = response.get_json()
    assert data['gameId'] is not None
    assert len(data['players']) == 4
    assert data['players'][0]['name'] == 'Test Player'

def test_get_game_state_not_found(client):
    response = client.post('/api/game/nonexistent/next')
    assert response.status_code == 404


=========================================
FILE: ./texas-holdem-backend/tests/test_deck.py
=========================================
import unittest
from game.deck import Deck
from game.card import Card

class TestDeck(unittest.TestCase):

    def setUp(self):
        """Set up a new deck for each test."""
        self.deck = Deck()

    def test_deck_creation(self):
        """Test if the deck is created with 52 unique cards."""
        self.assertEqual(len(self.deck._cards), 52, "Deck should have 52 cards")
        
        # Use private attribute _cards for verification
        card_strings = {card.to_str() for card in self.deck._cards}
        self.assertEqual(len(card_strings), 52, "All cards in the deck should be unique")

    def test_shuffle(self):
        """Test if the shuffle method actually changes the order of cards."""
        initial_order = [card.to_str() for card in self.deck._cards]
        self.deck.shuffle()
        shuffled_order = [card.to_str() for card in self.deck._cards]
        
        # It is statistically possible but highly unlikely to be equal
        self.assertNotEqual(initial_order, shuffled_order, "Shuffle should change the card order")
        self.assertEqual(len(shuffled_order), 52, "Shuffled deck should still have 52 cards")

    def test_deal(self):
        """Test dealing a card from the deck."""
        # Note: Deck logic usually deals from index 0 or pops. 
        # Our implementation slices from 0.
        top_card = self.deck._cards[0] 
        
        # Deal returns a LIST of cards
        dealt_cards = self.deck.deal(1)
        dealt_card = dealt_cards[0]
        
        self.assertIsInstance(dealt_card, Card, "Dealt object should be a Card")
        self.assertEqual(dealt_card.to_str(), top_card.to_str(), "Deal should return the top card")
        self.assertEqual(len(self.deck._cards), 51, "Deck should have 51 cards after dealing one")

    def test_deal_empty_deck(self):
        """Test that dealing from an empty deck raises an error."""
        # Deal all 52 cards
        self.deck.deal(52)
        
        self.assertEqual(len(self.deck._cards), 0, "Deck should be empty")
        
        # Expect a ValueError when dealing from an empty deck
        with self.assertRaises(ValueError):
            self.deck.deal(1)


=========================================
FILE: ./texas-holdem-backend/tests/test_engine.py
=========================================
import pytest
from game.engine import GameEngine
from game.player import Player

@pytest.fixture
def players():
    # Uses 'id' instead of 'player_id'
    return [
        Player(id=0, name="p0", chips=1000, is_human=True),
        Player(id=1, name="p1", chips=1000),
        Player(id=2, name="p2", chips=1000),
        Player(id=3, name="p3", chips=1000),
    ]

def test_start_new_hand(players):
    engine = GameEngine(players)
    
    assert engine.stage == 'PRE_FLOP'
    assert engine.pot == 30  # 10 SB + 20 BB
    assert engine.bet_to_call == 20
    
    # Dealer Logic Correction:
    # Engine initialized dealer_pos=0.
    # start_new_hand increments immediately -> Dealer=1.
    # SB = (1+1)%4 = 2.
    # BB = (1+2)%4 = 3.
    # UTG = (3+1)%4 = 0.

    assert engine.dealer_pos == 1

    sb_player = engine.players[2]
    bb_player = engine.players[3]
    utg_player = engine.players[0]
    
    assert sb_player.chips == 990
    assert sb_player.current_bet == 10
    assert bb_player.chips == 980
    assert bb_player.current_bet == 20

    # Player 0 (UTG) is first to act
    assert engine.active_player_id == 0

def test_player_action_fold(players):
    engine = GameEngine(players)
    
    # Player 0 is UTG. Fold.
    player_id = 0
    engine.process_player_action(player_id, "fold")
    
    assert engine.players[player_id].is_folded
    # Action moves to next player: 1 (Dealer)
    assert engine.active_player_id == 1

def test_player_action_call(players):
    engine = GameEngine(players)
    
    # Player 0 is UTG. Call 20.
    player_id = 0
    engine.process_player_action(player_id, "call")

    player_0 = engine.players[player_id]
    assert player_0.chips == 980
    assert player_0.current_bet == 20
    assert engine.pot == 50 
    assert engine.active_player_id == 1

def test_player_action_raise(players):
    engine = GameEngine(players)
    
    # Player 0 (UTG) raises TO 60
    player_id = 0
    amount = 60
    engine.process_player_action(player_id, "raise", amount)

    player_0 = engine.players[player_id]
    assert player_0.chips == 940
    assert player_0.current_bet == 60
    assert engine.bet_to_call == 60
    assert engine.active_player_id == 1


=========================================
FILE: ./texas-holdem-backend/tests/test_hand_evaluator.py
=========================================
import unittest
from typing import List
from game.hand_evaluator import evaluate_hand
from game.card import Card, Rank, Suit

class TestHandEvaluator(unittest.TestCase):

    def _create_cards_from_strings(self, card_strs: List[str]) -> List[Card]:
        """Helper to make cards from 'AS', 'KH' etc."""
        cards = []
        rank_map = {'A': Rank.ACE, 'K': Rank.KING, 'Q': Rank.QUEEN, 'J': Rank.JACK, 'T': Rank.TEN,
                    '9': Rank.NINE, '8': Rank.EIGHT, '7': Rank.SEVEN, '6': Rank.SIX, '5': Rank.FIVE,
                    '4': Rank.FOUR, '3': Rank.THREE, '2': Rank.TWO}
        suit_map = {'S': Suit.SPADES, 'H': Suit.HEARTS, 'D': Suit.DIAMONDS, 'C': Suit.CLUBS}
        
        for s in card_strs:
            rank = rank_map[s[0]]
            suit = suit_map[s[1]]
            cards.append(Card(rank, suit))
        return cards

    def test_royal_flush(self):
        cards = self._create_cards_from_strings(['AS', 'KS', 'QS', 'JS', 'TS', '3D', '4C'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 9) # 9 = Straight Flush / Royal

    def test_four_of_a_kind(self):
        cards = self._create_cards_from_strings(['AC', 'AD', 'AS', 'AH', 'KH', 'QD', 'JC'])
        rank, kickers = evaluate_hand(cards)
        self.assertEqual(rank, 8) # 8 = Four of a Kind
        # Kicker logic: [QuadRank, KickerRank] -> [14, 13]
        self.assertEqual(kickers[1], 13) 

    def test_full_house(self):
        cards = self._create_cards_from_strings(['KC', 'KD', 'KS', 'QH', 'QD', 'JC', '2S'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 7) # 7 = Full House

    def test_flush(self):
        cards = self._create_cards_from_strings(['KH', 'QH', '7H', '5H', '2H', 'AD', 'AC'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 6) # 6 = Flush

    def test_straight(self):
        cards = self._create_cards_from_strings(['TC', '9D', '8S', '7H', '6C', 'AD', '2S'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 5) # 5 = Straight

    def test_three_of_a_kind(self):
        cards = self._create_cards_from_strings(['QC', 'QD', 'QS', 'KH', 'JD', '7C', '5S'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 4) # 4 = Set

    def test_two_pair(self):
        cards = self._create_cards_from_strings(['KC', 'KD', 'JS', 'JH', 'AD', '7C', '5S'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 3) # 3 = Two Pair

    def test_one_pair(self):
        cards = self._create_cards_from_strings(['AC', 'AD', 'KS', 'JH', '7D', '5C', '3S'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 2) # 2 = Pair
        
    def test_high_card(self):
        cards = self._create_cards_from_strings(['AD', 'KS', 'JH', '7D', '5C', '3S', '2H'])
        rank, _ = evaluate_hand(cards)
        self.assertEqual(rank, 1) # 1 = High Card


=========================================
FILE: ./texas-holdem-backend/tests/test_player.py
=========================================
import unittest
from game.player import Player

class TestPlayer(unittest.TestCase):

    def setUp(self):
        """Set up a player for each test."""
        # Use 'id' keyword arg
        self.player = Player(id=1, name="TestBot", chips=1000)

    def test_player_initialization(self):
        """Test if player attributes are initialized correctly."""
        self.assertEqual(self.player.id, 1)
        self.assertEqual(self.player.name, "TestBot")
        self.assertEqual(self.player.chips, 1000)
        self.assertFalse(self.player.is_folded)
        self.assertEqual(self.player.current_bet, 0)

    def test_place_bet(self):
        """Test placing a valid bet (named 'bet' in new impl)."""
        self.player.bet(100)
        self.assertEqual(self.player.chips, 900)
        self.assertEqual(self.player.current_bet, 100)
        
        # Test placing another bet (cumulative logic handled by caller/player state)
        # The method .bet(amount) reduces chips by 'amount' and adds to current_bet
        self.player.bet(50)
        self.assertEqual(self.player.chips, 850)
        self.assertEqual(self.player.current_bet, 150)

    def test_place_bet_all_in(self):
        """Test betting all chips."""
        self.player.bet(1000)
        self.assertEqual(self.player.chips, 0)
        self.assertEqual(self.player.current_bet, 1000)
        self.assertTrue(self.player.is_all_in)

    def test_place_bet_insufficient_funds(self):
        """Test logic for betting more than chips (should cap at stack)."""
        # The new implementation .bet() clamps the value, doesn't raise Error
        # but simply bets everything they have.
        added = self.player.bet(1001)
        
        self.assertEqual(added, 1000) # Should only take what they have
        self.assertEqual(self.player.chips, 0)
        self.assertTrue(self.player.is_all_in)

    def test_fold(self):
        """Test the fold action."""
        self.player.fold()
        self.assertTrue(self.player.is_folded)
        self.assertEqual(self.player.last_action, "Fold")

    def test_reset_for_new_hand(self):
        """Test resetting player state for a new hand."""
        self.player.bet(100)
        self.player.fold()
        self.player.hand.append("dummy_card")
        
        # New method name is reset_hand_state
        self.player.reset_hand_state()
        
        self.assertEqual(self.player.hand, [])
        self.assertEqual(self.player.current_bet, 0)
        self.assertFalse(self.player.is_folded)
        self.assertFalse(self.player.is_all_in)


=========================================
FILE: ./texas-holdem-backend/tests/test_poker_logic.py
=========================================
import pytest
from game.card import Card, Rank, Suit
from game.deck import Deck
from game.hand_evaluator import evaluate_hand

def test_deck_integrity():
    d = Deck()
    assert len(d._cards) == 52
    # Test randomness implicitly by checking first card differs eventually? 
    # Better: check unique cards
    uniques = set((c.rank, c.suit) for c in d._cards)
    assert len(uniques) == 52

def test_evaluation_ordering():
    # Royal Flush
    royal = [Card(Rank.ACE, Suit.HEARTS), Card(Rank.KING, Suit.HEARTS), 
             Card(Rank.QUEEN, Suit.HEARTS), Card(Rank.JACK, Suit.HEARTS), 
             Card(Rank.TEN, Suit.HEARTS)]
    
    # Full House
    fh = [Card(Rank.TEN, Suit.CLUBS), Card(Rank.TEN, Suit.DIAMONDS), 
          Card(Rank.TEN, Suit.SPADES), Card(Rank.TWO, Suit.CLUBS), 
          Card(Rank.TWO, Suit.DIAMONDS)]
          
    score_royal, _ = evaluate_hand(royal)
    score_fh, _ = evaluate_hand(fh)
    
    assert score_royal == 9 # Straight Flush (Top category)
    assert score_fh == 7 # Full House
    assert score_royal > score_fh

def test_kicker_logic():
    # Pair of Aces, King Kicker
    h1 = [Card(Rank.ACE, Suit.HEARTS), Card(Rank.ACE, Suit.CLUBS),
          Card(Rank.KING, Suit.HEARTS), Card(Rank.TWO, Suit.CLUBS), Card(Rank.THREE, Suit.CLUBS)]
    
    # Pair of Aces, Queen Kicker
    h2 = [Card(Rank.ACE, Suit.DIAMONDS), Card(Rank.ACE, Suit.SPADES),
          Card(Rank.QUEEN, Suit.HEARTS), Card(Rank.TWO, Suit.DIAMONDS), Card(Rank.THREE, Suit.DIAMONDS)]
          
    s1, k1 = evaluate_hand(h1)
    s2, k2 = evaluate_hand(h2)
    
    assert s1 == s2 == 2 # One Pair
    assert k1 > k2 # King > Queen kicker

=========================================
FILE: ./texas-holdem-backend/.env
=========================================
GOOGLE_API_KEY="AIzaSyDWX4FYb4emicwDHMd4p4aIA3T-jQpjArA"
FLASK_ENV=development

=========================================
FILE: ./texas-holdem-backend/Dockerfile
=========================================
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 5001

CMD ["python", "app.py"]

=========================================
FILE: ./texas-holdem-frontend/.gitignore
=========================================



=========================================
FILE: ./texas-holdem-frontend/App.tsx
=========================================
import React from 'react';
import { ActionControls } from './components/ActionControls';
import { useGameEngine } from './hooks/useGameEngine';
import GameBoard from './components/GameBoard';

const App: React.FC = () => {
  const { gameState, handlePlayerAction, newGame, nextHand, isLoading, error } = useGameEngine();

  if (!gameState) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen p-6">
        <h1 className="app-title text-4xl sm:text-5xl mb-6">Texas Hold'em</h1>
        <p className="text-gray-300 mb-8">The ultimate AI Poker experience</p>
        <button
          onClick={newGame}
          disabled={isLoading}
          className="pill-btn btn-raise"
          style={{ padding: '14px 28px' }}
        >
          {isLoading ? 'Starting...' : 'Start New Game'}
        </button>
        {error && <p className="text-red-500 mt-4">{error}</p>}
      </div>
    );
  }

  const humanPlayer = gameState.players.find(p => p.isHuman);

  return (
    <main className="flex flex-col items-center justify-start h-screen overflow-hidden p-2 md:p-4">
      <header className="w-full p-2 md:p-6 flex justify-center z-50">
        <h1 className="app-title text-2xl md:text-4xl">Texas Hold'em</h1> 
      </header>
      <div className="flex-grow w-full flex items-center justify-center overflow-hidden">
        <GameBoard gameState={gameState} />
      </div>
      <footer className="w-full flex justify-center p-2 md:p-4">
        <div className="w-full max-w-4xl">
          {gameState.stage !== 'HAND_OVER' && humanPlayer && (
              <ActionControls
                  player={humanPlayer}
                  pot={gameState.pot}
                  onAction={handlePlayerAction}
                  currentBet={gameState.betToCall}
                  isActive={gameState.activePlayerId === humanPlayer.id}
              />
          )}
          {gameState.stage === 'HAND_OVER' && (
             <div className="flex flex-col items-center justify-center h-40 w-full">
                  <button onClick={nextHand} disabled={isLoading} className="pill-btn btn-raise">
                      {isLoading ? '...' : 'Next Hand'}
                  </button>
              </div>
          )}
        </div>
      </footer>
    </main>
  );
};

export default App;


=========================================
FILE: ./texas-holdem-frontend/README.md
=========================================
<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/drive/1QnfAYFLei4Jfhv3qMQzULpC0uLEBgzaZ

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`


=========================================
FILE: ./texas-holdem-frontend/components/ActionControls.tsx
=========================================
import React, { useState, useEffect, useMemo } from 'react';
import { Player, PlayerAction } from '../types';
import { motion, AnimatePresence } from 'framer-motion';

interface ActionControlsProps {
  player: Player;
  pot: number;
  onAction: (action: PlayerAction, amount?: number) => void;
  currentBet: number;
  isActive: boolean;
}

export const ActionControls: React.FC<ActionControlsProps> = ({ player, pot, onAction, currentBet, isActive }) => {
    const minRaise = useMemo(() => Math.max(currentBet > 0 ? currentBet * 2 : 20, 20), [currentBet]);
    const [betAmount, setBetAmount] = useState(minRaise);

    const callAmount = currentBet - player.currentBet;
    const canCheck = callAmount <= 0;

    const quickBets = useMemo(() => [
        { label: '1/2 Pot', value: Math.max(minRaise, Math.floor((pot + currentBet) / 2)) },
        { label: 'Pot', value: Math.max(minRaise, pot + currentBet) },
        { label: 'All In', value: player.chips + player.currentBet },
    ], [pot, player, minRaise, currentBet]);

    useEffect(() => {
        setBetAmount(minRaise);
    }, [minRaise]);
    
    const handleActionWithVibration = (actionFn: () => void) => {
        navigator.vibrate?.(50);
        actionFn();
    };

    const handleBetChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setBetAmount(parseInt(e.target.value, 10) || 0);
    };
    
    const handleFold = () => handleActionWithVibration(() => onAction('fold'));
    const handleCheckOrCall = () => handleActionWithVibration(() => onAction(canCheck ? 'check' : 'call'));
    const handleBetOrRaise = () => {
        // Use the sanitized amount (minRaise <= amount <= stack)
        const finalAmount = Math.max(minRaise, Math.min(betAmount, player.chips + player.currentBet));
        
        // Determine action: raise if calling is required AND player has chips remaining, otherwise bet.
        const actionType = (currentBet > 0 && callAmount < player.chips) ? 'raise' : 'bet';
        
        handleActionWithVibration(() => onAction(actionType, finalAmount));
    };
  
    const sanitizedBetAmount = Math.min(betAmount, player.chips + player.currentBet);

    return (
        <fieldset 
            disabled={!isActive} 
            className="w-full max-w-4xl transition-opacity duration-300 disabled:opacity-50"
        >
          <div className="flex flex-col items-center justify-center space-y-3 p-3 bg-gradient-to-b from-gray-900/90 to-gray-800/90 backdrop-blur-sm rounded-xl shadow-2xl border border-yellow-600/30">
            <div className="w-full h-1.5 bg-gray-700 rounded-full overflow-hidden">
                <AnimatePresence>
                    {isActive && (
                        <motion.div className="h-full bg-gradient-to-r from-yellow-500 to-red-500 origin-left"
                            key={`timer-${player.id}`}
                            initial={{ scaleX: 1 }}
                            animate={{ scaleX: 0 }}
                            transition={{ duration: 30, ease: 'linear' }}
                        />
                    )}
                </AnimatePresence>
            </div>
    
            <div className="flex flex-wrap items-stretch justify-center gap-3 w-full p-2">
                
                {/* 1. FOLD BUTTON */}
                <button onClick={handleFold} 
                    className="flex-grow sm:flex-grow-0 px-6 py-3 rounded-lg font-bold uppercase tracking-wider text-sm transition-all active:scale-95 shadow-lg
                    bg-gradient-to-b from-gray-700 to-gray-900 text-red-500 border-t border-gray-600 border-b-4 border-black hover:brightness-110">
                    Fold
                </button>
                
                {/* 2. CHECK / CALL BUTTON */}
                <button onClick={handleCheckOrCall} 
                    className={`flex-grow sm:flex-grow-0 px-6 py-3 rounded-lg font-bold uppercase tracking-wider text-sm transition-all active:scale-95 shadow-lg text-white border-t border-blue-400 border-b-4 border-blue-900 hover:brightness-110
                    ${canCheck 
                        ? 'bg-gradient-to-b from-blue-500 to-blue-700' 
                        : 'bg-gradient-to-b from-blue-600 to-blue-800'}`}>
                    {canCheck ? 'Check' : `Call $${callAmount}`}
                </button>
                
                {/* 3. BET / RAISE BUTTON */}
                <button onClick={handleBetOrRaise} disabled={sanitizedBetAmount < minRaise} 
                    className="flex-grow sm:flex-grow-0 px-6 py-3 rounded-lg font-bold uppercase tracking-wider text-sm transition-all active:scale-95 shadow-lg
                    bg-gradient-to-b from-amber-400 to-amber-600 text-black border-t border-amber-300 border-b-4 border-amber-800 hover:brightness-110 disabled:opacity-50 disabled:grayscale disabled:cursor-not-allowed">
                    {currentBet > 0 ? `Raise $${sanitizedBetAmount}` : `Bet $${sanitizedBetAmount}`}
                </button>
            </div>
    
            <div className="w-full flex flex-col items-center space-y-2 pt-1">
                <input type="range" 
                    min={minRaise} 
                    max={player.chips + player.currentBet} 
                    step="10" 
                    value={betAmount} 
                    onChange={handleBetChange} 
                    className="w-full max-w-md accent-yellow-500 disabled:cursor-not-allowed" />
                
                <div className="flex items-center justify-center space-x-3">
                    {quickBets.map(({label, value}) => (
                        <button key={label} onClick={() => setBetAmount(value)} 
                            className="px-3 py-1.5 bg-amber-700 hover:bg-amber-800 text-white text-xs font-bold rounded-full shadow-md transition-all hover:scale-105 border border-amber-900 disabled:cursor-not-allowed disabled:hover:scale-100">
                            {label}
                        </button>
                    ))}
                </div>
            </div>
          </div>
        </fieldset>
    );
};


=========================================
FILE: ./texas-holdem-frontend/components/Card.tsx
=========================================
import React from 'react';

interface CardProps {
  card: string;
  small?: boolean;
}

const SUIT_STYLES: { [key: string]: { color: string; symbol: string; shadow: string } } = {
  H: { color: 'text-red-500', symbol: '♥', shadow: 'drop-shadow(0 2px 8px rgba(239,68,68,0.18))' },
  D: { color: 'text-red-500', symbol: '♦', shadow: 'drop-shadow(0 2px 6px rgba(239,68,68,0.12))' },
  S: { color: 'text-gray-900', symbol: '♠', shadow: 'drop-shadow(0 2px 6px rgba(0,0,0,0.18))' },
  C: { color: 'text-gray-900', symbol: '♣', shadow: 'drop-shadow(0 2px 6px rgba(0,0,0,0.18))' },
};

export const Card: React.FC<CardProps> = ({ card, small = false }) => {
  if (card === 'BACK') {
    const sizeClasses = small ? 'w-12 h-16' : 'w-20 h-28';
    return (
      <div className={`${sizeClasses} card card-small flex items-center justify-center`} style={{ background: 'linear-gradient(180deg,#0b2b2a,#0b2b2a)', borderRadius: small ? 8 : 10 }}>
          <div style={{ width: '70%', height: '70%', borderRadius: 6, border: '2px solid rgba(255,255,255,0.06)', background: 'linear-gradient(180deg,#082927,#063b3a)' }} />
      </div>
    );
  }

  const rank = card.slice(0, -1);
  const suit = card.slice(-1);
  const styles = SUIT_STYLES[suit];

  if (small) {
    return (
      <div className={`w-12 h-16 card card-small p-1 flex flex-col justify-between relative`} >
        <div style={{ color: styles.color === 'text-red-500' ? '#dc2626' : '#111827', fontWeight: 700 }}>
          <div className="absolute top-1 left-1 text-sm">{rank}</div>
          <div className="absolute top-5 left-1 text-xs">{styles.symbol}</div>
        </div>
        <div className={`self-end font-bold text-2xl`} style={{ color: styles.color === 'text-red-500' ? '#dc2626' : '#111827', filter: styles.shadow }}>
          {styles.symbol}
        </div>
      </div>
    );
  }

  return (
    <div className={`w-16 h-24 sm:w-20 sm:h-28 card p-2 flex flex-col justify-between relative`}>
      <div style={{ color: styles.color === 'text-red-500' ? '#dc2626' : '#111827', fontWeight: 800 }}>
        <div className="absolute top-2 left-3 text-lg sm:text-xl">{rank}</div>
        <div className="absolute top-8 left-3 text-lg sm:text-xl">{styles.symbol}</div>
      </div>
      <div className={`self-center font-extrabold text-4xl sm:text-5xl`} style={{ color: styles.color === 'text-red-500' ? '#dc2626' : '#111827' }}>
        {styles.symbol}
      </div>
      <div style={{ color: styles.color === 'text-red-500' ? '#dc2626' : '#111827', fontWeight: 800 }}>
        <div className="absolute bottom-2 right-3 transform rotate-180 text-lg sm:text-xl">{rank}</div>
        <div className="absolute bottom-8 right-3 transform rotate-180 text-lg sm:text-xl">{styles.symbol}</div>
      </div>
    </div>
  );
};


=========================================
FILE: ./texas-holdem-frontend/components/ChipPile.tsx
=========================================
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface ChipPileProps {
  amount: number;
  size?: 'small' | 'large';
}
interface ChipProps {
  value: number;
  bodyColor: string;
  stripeColor: string;
  textColor: string;
}

const CHIP_DENOMINATIONS: ChipProps[] = [
    { value: 100, bodyColor: '#1f2937', stripeColor: '#ffffff', textColor: '#ffffff' }, // Black
    { value: 25, bodyColor: '#059669', stripeColor: '#ffffff', textColor: '#ffffff' }, // Green
    { value: 10, bodyColor: '#2563eb', stripeColor: '#ffffff', textColor: '#ffffff' }, // Blue
    { value: 5, bodyColor: '#ef4444', stripeColor: '#ffffff', textColor: '#ffffff' }, // Red
    { value: 1, bodyColor: '#f3f4f6', stripeColor: '#4b5563', textColor: '#111827' }, // White
];

const SingleChip: React.FC<ChipProps & { isTop: boolean; sizeScale?: number }> = ({ bodyColor, stripeColor, textColor, value, isTop, sizeScale = 1 }) => {
    const gradientId = `grad-${value}-${bodyColor.replace('#','')}`;
    const size = Math.round(48 * sizeScale);
    return (
        <svg width={size} height={size} viewBox="0 0 100 100" style={{ overflow: 'visible' }}>
            <defs>
                <radialGradient id={gradientId} cx="45%" cy="35%" r="55%">
                    <stop offset="0%" style={{ stopColor: 'rgba(255,255,255,0.45)' }} />
                    <stop offset="100%" style={{ stopColor: 'rgba(0,0,0,0.25)' }} />
                </radialGradient>
            </defs>

            <circle cx="50" cy="55" r="48" fill="#000" opacity="0.45" />
            <circle cx="50" cy="50" r="48" fill={bodyColor} stroke="#111827" strokeWidth="1" />
            <g>
                {Array.from({ length: 4 }).map((_, i) => (
                    <rect key={i} x="44" y="0" width="12" height="100" fill={stripeColor} opacity="0.9" transform={`rotate(${i * 45 + 22.5} 50 50)`} />
                ))}
            </g>
            <circle cx="50" cy="50" r="36" fill={bodyColor} />
            <circle cx="50" cy="50" r="48" fill="none" stroke="rgba(255,255,255,0.08)" strokeWidth="2" />
            <circle cx="50" cy="50" r="36" fill="none" stroke={stripeColor} strokeWidth="1.6" opacity="0.9" />
            <circle cx="50" cy="50" r="48" fill={`url(#${gradientId})`} style={{ mixBlendMode: 'soft-light', opacity: 0.9 }} />
            {isTop && (
                <text
                    x="50"
                    y="50"
                    dy="0.35em"
                    fontSize="24"
                    fontWeight="700"
                    fill={textColor}
                    textAnchor="middle"
                    fontFamily="Inter, Arial, sans-serif"
                    stroke="#000"
                    strokeWidth="0.6"
                    strokeOpacity="0.3"
                >
                    {value}
                </text>
            )}
        </svg>
    );
};

const getChipStack = (amount: number): ChipProps[] => {
  if (amount <= 0) return [];
  const MAX_CHIPS_IN_STACK = 10;
  let remaining = amount;
  const chips: ChipProps[] = [];
  for (const denom of CHIP_DENOMINATIONS) {
    const count = Math.floor(remaining / denom.value);
    for (let i = 0; i < count; i++) {
      chips.push(denom);
    }
    remaining %= denom.value;
  }
  if (remaining > 0) {
    chips.push(CHIP_DENOMINATIONS[CHIP_DENOMINATIONS.length - 1]);
  }
  return chips.slice(0, MAX_CHIPS_IN_STACK).reverse();
};

export const ChipPile: React.FC<ChipPileProps> = ({ amount, size = 'large' }) => {
  const chipStack = getChipStack(amount);
  if (chipStack.length === 0) return null;
  const scale = size === 'small' ? 0.62 : 1;  // Scale down for stacks
  return (
    <div className="chip-stack-wrap relative flex items-center justify-center" style={{ width: 60 * scale, height: 60 * scale }}>
      <AnimatePresence>
        <motion.div
          className="absolute"
          style={{ transform: `scale(${scale})` }}
          initial={{ scale: 0.6, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.6, opacity: 0 }}
          transition={{ type: 'spring', damping: 18, stiffness: 220 }}
        >
          {chipStack.map((chip, i) => {
            const isTop = i === chipStack.length - 1;
            return (
              <div
                key={i}
                className="absolute left-1/2 -translate-x-1/2"
                style={{
                  transform: `translateY(-${i * 6}px)`,
                  zIndex: i,
                  filter: 'drop-shadow(0 8px 18px rgba(0,0,0,0.45))',
                }}
              >
                <SingleChip {...chip} isTop={isTop} />
              </div>
            );
          })}
        </motion.div>
      </AnimatePresence>
    </div>
  );
};


=========================================
FILE: ./texas-holdem-frontend/components/GameBoard.tsx
=========================================
import React, { useState, useEffect } from 'react';
import { Player } from './Player';
import { Card } from './Card';
import { ChipPile } from './ChipPile';
import { WinnerOverlay } from './WinnerOverlay';
import { HandStrength } from './HandStrength';
import { motion } from 'framer-motion';
import { GameState } from '../types';

import "../styles/GameBoard.css";

// The component receives a single 'gameState' object.
interface GameBoardProps {
  gameState: GameState;
}

const GameBoard: React.FC<GameBoardProps> = ({ gameState }) => {
  const [showWinnerOverlay, setShowWinnerOverlay] = useState(false);
  const [previousStage, setPreviousStage] = useState<string | null>(null);

  // Destructure the necessary properties from the gameState object.
  const { players, communityCards, pot, activePlayerId, dealerId, smallBlindPlayerId, bigBlindPlayerId, stage, winners } = gameState;

  // Show winner overlay when hand ends
  useEffect(() => {
    if (stage === 'HAND_OVER' && previousStage !== 'HAND_OVER' && winners && winners.length > 0) {
      setShowWinnerOverlay(true);
    }
    setPreviousStage(stage);
  }, [stage, previousStage, winners]);

  // This check handles the initial state before players are populated.
  if (!players) {
    return null;
  }

  const showCards = stage === 'SHOWDOWN' || stage === 'HAND_OVER';
  const humanPlayer = players.find(p => p.isHuman);
  const winnerPlayers = winners ? players.filter(p => winners.includes(p.id)) : [];
  const isHumanWinner = humanPlayer ? (winners?.includes(humanPlayer.id) ?? false) : false;

  return (
    <div className="game-board w-full h-full flex items-center justify-center">
      {/* Winner Overlay */}
      {showWinnerOverlay && winnerPlayers.length > 0 && (
        <WinnerOverlay
          winners={winnerPlayers}
          pot={pot}
          isHumanWinner={isHumanWinner}
          onClose={() => setShowWinnerOverlay(false)}
        />
      )}

      <div className="table-wrapper">
        <motion.div
          className="poker-table"
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.4 }}
        >
          <div className="table-surface relative">
            {/* Community cards */}
            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center justify-center gap-2">
              <div className="flex gap-1.5 md:gap-2.5" style={{ minHeight: '112px' }}>
                {communityCards.map((card, i) => (
                  <motion.div key={i} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ delay: i * 0.1 }}>
                    <Card card={card} />
                  </motion.div>
                ))}
              </div>
            </div>

            {/* Pot display */}
            <div className="absolute top-[calc(50%+65px)] left-1/2 -translate-x-1/2 -translate-y-1/2 flex flex-col items-center">
              <span className="text-white font-bold text-lg drop-shadow-lg">Pot: ${pot}</span>
              <ChipPile amount={pot} />
            </div>

            {/* Players around table */}
            {players.map((player) => (
              <div key={player.id} className={`player-position player-pos-${player.id}-${players.length}`}>
                <Player
                  player={player}
                  isActive={player.id === activePlayerId}
                  isDealer={player.id === dealerId}
                  isSmallBlind={player.id === smallBlindPlayerId}
                  isBigBlind={player.id === bigBlindPlayerId}
                  showCards={showCards || player.isHuman}
                />
              </div>
            ))}

            {/* Hand Strength Indicator for human player */}
            {humanPlayer && stage !== 'HAND_OVER' && (
              <div className="absolute bottom-[5%] right-[5%] z-30">
                <HandStrength
                  hand={humanPlayer.hand}
                  communityCards={communityCards}
                />
              </div>
            )}
          </div>
        </motion.div>
      </div>
    </div>
  );
};

export default GameBoard;



=========================================
FILE: ./texas-holdem-frontend/components/Player.tsx
=========================================
import React from 'react';
import { Player as PlayerType } from '../types';
import { Card } from './Card';
import { ChipPile } from './ChipPile';
import { motion, AnimatePresence } from 'framer-motion';

interface PlayerProps {
  player: PlayerType;
  isActive: boolean;
  isDealer: boolean;
  isSmallBlind: boolean;
  isBigBlind: boolean;
  showCards: boolean;
}

export const Player: React.FC<PlayerProps> = ({ player, isActive, isDealer, isSmallBlind, isBigBlind, showCards }) => {
  
  // LOGIC: Bets always go towards the center of the table (The Pot)
  // Using fixed pixels (rem) is safer than percentages here to avoid overlap
  const getBetPositionClass = () => {
      if(player.isHuman) return 'bottom-[6rem] left-1/2 -translate-x-1/2'; 
      if(player.id === 2) return 'top-[6rem] left-1/2 -translate-x-1/2';    
      if(player.id === 1) return 'top-1/2 -translate-y-1/2 left-[8rem]';    
      if(player.id === 3) return 'top-1/2 -translate-y-1/2 right-[8rem]';   
      return '';
  }

  // LOGIC: Stacks tucked tight against the pod
  const getStackPositionClass = () => {
    if (player.isHuman) return 'top-1/2 -translate-y-1/2 left-[-3.5rem]';      
    if (player.id === 2) return 'top-1/2 -translate-y-1/2 right-[-3.5rem]';     
    if (player.id === 1) return 'bottom-[-3.5rem] left-1/2 -translate-x-1/2';     
    if (player.id === 3) return 'bottom-[-3.5rem] left-1/2 -translate-x-1/2';      
    return '';
  }

  const getStatusText = () => {
    if (isActive) return <span className="font-bold text-yellow-400 animate-pulse">Thinking...</span>;
    if (player.isFolded) return <span className="text-gray-500">Folded</span>;
    let status = player.lastAction || '';
    if (player.isAllIn) return status ? `${status} (ALL IN)` : 'ALL IN';
    if (status) return <span className="text-cyan-300">{status}</span>;
    return 'Waiting';
  };

  const avatarIcons: { [key: string]: string } = {
      'Viper': '🐍',
      'Mountain': '🏔️',
      'Shark': '🦈',
  };

  const playerIcon = player.isHuman ? '👑' : (avatarIcons[player.name] || player.name.charAt(0));
  // Overlap cards slightly for a tighter look
  const cardSpacing = player.isHuman ? 'space-x-[-30px]' : 'space-x-[-40px]';
  const cardSize = !player.isHuman;

  return (
    <motion.div
        className="relative flex flex-col items-center justify-center w-[120px]"
        animate={{
            opacity: player.isFolded ? 0.5 : 1,
            scale: isActive ? 1.05 : 1,
            filter: player.isFolded ? 'grayscale(80%) blur(0.5px)' : 'grayscale(0%) blur(0px)'
        }}
        transition={{ type: 'spring', stiffness: 300, damping: 22 }}
        layout
    >
        {/* CURRENT BET BUBBLE (Towards Center) */}
        <div className={`absolute z-40 ${getBetPositionClass()}`}>
            <AnimatePresence>
            {player.currentBet > 0 && (
                <motion.div
                    layoutId={`bet-${player.id}`}
                    initial={{ opacity: 0, scale: 0.5, y: 20 }}
                    animate={{ opacity: 1, scale: 1, y: 0 }}
                    exit={{ opacity: 0, scale: 0.5 }}
                >
                    <ChipPile amount={player.currentBet} />
                </motion.div>
            )}
            </AnimatePresence>
        </div>

        {/* PLAYER POD */}
        <div className="relative z-30 w-full">
            <motion.div
                className={`player-pod relative text-white w-full ${isActive ? 'active-ring' : 'border-gray-700'}`}
                initial={{ y: 10, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
            >
                 {/* Avatar Circle */}
                 <div className={`absolute -top-5 left-1/2 -translate-x-1/2 w-10 h-10 rounded-full flex items-center justify-center text-xl font-bold border-2 border-gray-600 shadow-md z-20 bg-gray-800`} 
                      style={{ backgroundColor: player.isHuman ? '#b45309' : '#1f2937' }}>
                    <span className="drop-shadow-md">{playerIcon}</span>
                </div>
                
                <div className="pt-6 pb-2 px-2 text-center">
                    <p className="font-bold text-xs tracking-wide text-gray-200 truncate">{player.name}</p>
                    <div className="text-[9px] uppercase font-bold mt-0.5 h-3 flex items-center justify-center tracking-wider text-gray-400">
                        {getStatusText()}
                    </div>
                 </div>

                 {/* DEALER / BLIND BUTTONS */}
                 <div className="absolute top-[-6px] right-[-6px] flex -space-x-1 z-30">
                    {isDealer && <div className="w-4 h-4 rounded-full flex items-center justify-center font-bold bg-white text-black text-[8px] border border-gray-400 shadow-sm">D</div>}
                    {(isSmallBlind && !isDealer) && <div className="w-4 h-4 rounded-full flex items-center justify-center font-bold bg-blue-500 text-white text-[8px] border border-blue-300 shadow-sm">S</div>}
                    {(isBigBlind && !isDealer) && <div className="w-4 h-4 rounded-full flex items-center justify-center font-bold bg-purple-600 text-white text-[8px] border border-purple-300 shadow-sm">B</div>}
                </div>
            </motion.div>

            {/* TOTAL CHIPS STACK (Tucked Tight) */}
            <div className={`absolute z-20 ${getStackPositionClass()}`}>
                <AnimatePresence>
                    {player.chips > 0 && (
                        <motion.div
                            layoutId={`stack-${player.id}`}
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                        >
                            <ChipPile amount={player.chips} size="small" />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>

        {/* CARDS */}
        <motion.div
          className={`absolute left-1/2 -translate-x-1/2 flex justify-center ${cardSpacing} w-full pointer-events-none`}
          style={{
              // Human: Move cards UP (-4rem) to sit on the table, CLEAR of the nameplate
              // Bots: Move cards DOWN (3.5rem) to sit below nameplate
              top: player.isHuman ? '-4.5rem' : '3.8rem',
              zIndex: player.isHuman ? 50 : 10 
          }}
        >
            {(player.hand.length > 0 ? player.hand : ['BACK', 'BACK']).map((card, index) => (
                <motion.div 
                    key={index} 
                    initial={{ y: 10, opacity: 0 }} 
                    animate={{ y: 0, opacity: 1 }} 
                    transition={{ delay: index * 0.1 }}
                    className="origin-bottom"
                >
                    <Card card={showCards ? card : 'BACK'} small={cardSize} />
                </motion.div>
            ))}
        </motion.div>
    </motion.div>
  );
};


=========================================
FILE: ./texas-holdem-frontend/components/WinnerOverlay.tsx
=========================================
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Player } from '../types';

interface WinnerOverlayProps {
    winners: Player[];
    pot: number;
    isHumanWinner: boolean;
    onClose: () => void;
}

// Simple confetti particles
const Confetti: React.FC = () => {
    const colors = ['#fbbf24', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
    const particles = Array.from({ length: 50 }, (_, i) => ({
        id: i,
        x: Math.random() * 100,
        delay: Math.random() * 0.5,
        duration: 2 + Math.random() * 2,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: 6 + Math.random() * 8,
    }));

    return (
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
            {particles.map((p) => (
                <motion.div
                    key={p.id}
                    className="absolute rounded-sm"
                    style={{
                        left: `${p.x}%`,
                        top: '-20px',
                        width: p.size,
                        height: p.size,
                        backgroundColor: p.color,
                    }}
                    initial={{ y: 0, opacity: 1, rotate: 0 }}
                    animate={{
                        y: '120vh',
                        opacity: [1, 1, 0],
                        rotate: 360 * (Math.random() > 0.5 ? 1 : -1),
                    }}
                    transition={{
                        duration: p.duration,
                        delay: p.delay,
                        ease: 'easeIn',
                    }}
                />
            ))}
        </div>
    );
};

export const WinnerOverlay: React.FC<WinnerOverlayProps> = ({
    winners,
    pot,
    isHumanWinner,
    onClose,
}) => {
    const winnerNames = winners.map((w) => w.name).join(' & ');
    const shareAmount = Math.floor(pot / winners.length);

    return (
        <AnimatePresence>
            <motion.div
                className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                onClick={onClose}
            >
                {isHumanWinner && <Confetti />}

                <motion.div
                    className="relative bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 rounded-2xl p-8 shadow-2xl border border-yellow-500/30 max-w-md mx-4"
                    initial={{ scale: 0.8, y: 50 }}
                    animate={{ scale: 1, y: 0 }}
                    exit={{ scale: 0.8, y: 50 }}
                    transition={{ type: 'spring', damping: 20 }}
                    onClick={(e) => e.stopPropagation()}
                >
                    {/* Trophy icon */}
                    <motion.div
                        className="text-6xl text-center mb-4"
                        initial={{ scale: 0, rotate: -20 }}
                        animate={{ scale: 1, rotate: 0 }}
                        transition={{ type: 'spring', delay: 0.2 }}
                    >
                        {isHumanWinner ? '🏆' : '🎲'}
                    </motion.div>

                    {/* Winner announcement */}
                    <motion.h2
                        className="text-2xl md:text-3xl font-bold text-center mb-2"
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: 0.3 }}
                        style={{
                            background: 'linear-gradient(135deg, #fbbf24, #f59e0b)',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent',
                        }}
                    >
                        {isHumanWinner ? 'You Win!' : `${winnerNames} Wins!`}
                    </motion.h2>

                    {/* Pot amount */}
                    <motion.div
                        className="text-center mb-6"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ delay: 0.4 }}
                    >
                        <span className="text-gray-400 text-sm">Pot Won</span>
                        <div className="text-3xl font-bold text-green-400">${shareAmount}</div>
                        {winners.length > 1 && (
                            <span className="text-gray-500 text-xs">(Split {winners.length} ways)</span>
                        )}
                    </motion.div>

                    {/* Winner cards display */}
                    {winners[0]?.hand && winners[0].hand[0] !== 'BACK' && (
                        <motion.div
                            className="flex justify-center gap-2 mb-6"
                            initial={{ opacity: 0, y: 20 }}
                            animate={{ opacity: 1, y: 0 }}
                            transition={{ delay: 0.5 }}
                        >
                            {winners[0].hand.map((card, i) => (
                                <div
                                    key={i}
                                    className="w-12 h-16 bg-white rounded-lg shadow-lg flex items-center justify-center text-lg font-bold"
                                    style={{
                                        color: card.endsWith('H') || card.endsWith('D') ? '#dc2626' : '#111827',
                                    }}
                                >
                                    {card.slice(0, -1)}
                                    {card.endsWith('H') && '♥'}
                                    {card.endsWith('D') && '♦'}
                                    {card.endsWith('S') && '♠'}
                                    {card.endsWith('C') && '♣'}
                                </div>
                            ))}
                        </motion.div>
                    )}

                    {/* Continue button */}
                    <motion.button
                        className="w-full py-3 px-6 bg-gradient-to-r from-amber-500 to-amber-600 hover:from-amber-600 hover:to-amber-700 text-black font-bold rounded-xl shadow-lg transition-all"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ delay: 0.6 }}
                        onClick={onClose}
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                    >
                        Continue
                    </motion.button>
                </motion.div>
            </motion.div>
        </AnimatePresence>
    );
};


=========================================
FILE: ./texas-holdem-frontend/components/HandStrength.tsx
=========================================
import React, { useMemo } from 'react';
import { motion } from 'framer-motion';

interface HandStrengthProps {
    hand: string[];
    communityCards: string[];
}

// Card rank values
const RANK_VALUES: { [key: string]: number } = {
    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,
    '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14,
};

const RANK_NAMES: { [key: string]: string } = {
    '2': 'Twos', '3': 'Threes', '4': 'Fours', '5': 'Fives', '6': 'Sixes',
    '7': 'Sevens', '8': 'Eights', '9': 'Nines', '10': 'Tens',
    'J': 'Jacks', 'Q': 'Queens', 'K': 'Kings', 'A': 'Aces',
};

interface HandResult {
    rank: number;
    name: string;
    description: string;
    color: string;
}

function parseCard(card: string): { rank: string; suit: string } | null {
    if (!card || card === 'BACK') return null;
    const suit = card.slice(-1);
    const rank = card.slice(0, -1);
    return { rank, suit };
}

function evaluateHand(hand: string[], community: string[]): HandResult {
    const allCards = [...hand, ...community]
        .map(parseCard)
        .filter((c): c is { rank: string; suit: string } => c !== null);

    if (allCards.length < 2) {
        return { rank: 0, name: 'Waiting...', description: '', color: 'text-gray-400' };
    }

    // Count ranks and suits
    const rankCounts: { [key: string]: number } = {};
    const suitCounts: { [key: string]: number } = {};
    const rankValues: number[] = [];

    for (const card of allCards) {
        rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
        suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
        rankValues.push(RANK_VALUES[card.rank] || 0);
    }

    const pairs = Object.entries(rankCounts).filter(([, count]) => count === 2);
    const trips = Object.entries(rankCounts).filter(([, count]) => count === 3);
    const quads = Object.entries(rankCounts).filter(([, count]) => count === 4);
    const hasFlush = Object.values(suitCounts).some((count) => count >= 5);

    // Check for straight
    const uniqueRanks = [...new Set(rankValues)].sort((a, b) => b - a);
    let hasStraight = false;
    for (let i = 0; i <= uniqueRanks.length - 5; i++) {
        if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
            hasStraight = true;
            break;
        }
    }
    // Wheel straight (A-2-3-4-5)
    if (uniqueRanks.includes(14) && uniqueRanks.includes(2) && uniqueRanks.includes(3) &&
        uniqueRanks.includes(4) && uniqueRanks.includes(5)) {
        hasStraight = true;
    }

    // Determine hand rank
    if (hasStraight && hasFlush) {
        return { rank: 9, name: 'Straight Flush!', description: 'Incredible!', color: 'text-fuchsia-400' };
    }
    if (quads.length > 0) {
        return { rank: 8, name: 'Four of a Kind!', description: `Quad ${RANK_NAMES[quads[0][0]]}`, color: 'text-purple-400' };
    }
    if (trips.length > 0 && pairs.length > 0) {
        return { rank: 7, name: 'Full House!', description: `${RANK_NAMES[trips[0][0]]} full`, color: 'text-pink-400' };
    }
    if (hasFlush) {
        return { rank: 6, name: 'Flush', description: 'Five of same suit', color: 'text-blue-400' };
    }
    if (hasStraight) {
        return { rank: 5, name: 'Straight', description: 'Five in a row', color: 'text-cyan-400' };
    }
    if (trips.length > 0) {
        return { rank: 4, name: 'Three of a Kind', description: `Trip ${RANK_NAMES[trips[0][0]]}`, color: 'text-green-400' };
    }
    if (pairs.length >= 2) {
        const sortedPairs = pairs.sort((a, b) => RANK_VALUES[b[0]] - RANK_VALUES[a[0]]);
        return { rank: 3, name: 'Two Pair', description: `${RANK_NAMES[sortedPairs[0][0]]} & ${RANK_NAMES[sortedPairs[1][0]]}`, color: 'text-yellow-400' };
    }
    if (pairs.length === 1) {
        return { rank: 2, name: 'Pair', description: `Pair of ${RANK_NAMES[pairs[0][0]]}`, color: 'text-orange-400' };
    }

    // High card
    const highCard = allCards.reduce((max, card) =>
        (RANK_VALUES[card.rank] || 0) > (RANK_VALUES[max.rank] || 0) ? card : max
    );
    return { rank: 1, name: 'High Card', description: `${highCard.rank} high`, color: 'text-gray-300' };
}

export const HandStrength: React.FC<HandStrengthProps> = ({ hand, communityCards }) => {
    const result = useMemo(() => evaluateHand(hand, communityCards), [hand, communityCards]);

    // Calculate strength percentage (1-9 scale to 0-100)
    const strengthPercent = Math.min(100, (result.rank / 9) * 100);

    // Gradient colors based on strength
    const getGradient = () => {
        if (result.rank >= 7) return 'from-fuchsia-500 to-purple-600';
        if (result.rank >= 5) return 'from-blue-500 to-cyan-500';
        if (result.rank >= 3) return 'from-green-500 to-emerald-500';
        if (result.rank >= 2) return 'from-yellow-500 to-orange-500';
        return 'from-gray-500 to-gray-600';
    };

    if (hand.length === 0 || hand[0] === 'BACK') {
        return null;
    }

    return (
        <motion.div
            className="bg-gray-900/80 backdrop-blur-sm rounded-lg px-3 py-2 border border-gray-700/50 min-w-[140px]"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
        >
            <div className="flex items-center justify-between mb-1.5">
                <span className={`font-bold text-sm ${result.color}`}>{result.name}</span>
            </div>

            {result.description && (
                <div className="text-xs text-gray-400 mb-1.5">{result.description}</div>
            )}

            {/* Strength bar */}
            <div className="h-1.5 bg-gray-700 rounded-full overflow-hidden">
                <motion.div
                    className={`h-full bg-gradient-to-r ${getGradient()}`}
                    initial={{ width: 0 }}
                    animate={{ width: `${strengthPercent}%` }}
                    transition={{ duration: 0.5, ease: 'easeOut' }}
                />
            </div>
        </motion.div>
    );
};


=========================================
FILE: ./texas-holdem-frontend/hooks/useGameEngine.ts
=========================================
import { useState, useCallback, useEffect } from 'react';
import { GameState, PlayerAction } from '../types';
import { io, Socket } from 'socket.io-client';

const API_BASE_URL = 'http://localhost:5001';
const socket: Socket = io(API_BASE_URL);

export const useGameEngine = () => {
  const [gameState, setGameState] = useState<GameState | null>(null);
  const [message, setMessage] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const handleApiResponse = (data: GameState) => {
    setGameState(data);
    setError(null);
    setMessage(null);
  };

  useEffect(() => {
    socket.on('update', (newState: GameState) => {
        setIsLoading(false);
        handleApiResponse(newState);
    });

    socket.on('error', (err: { message: string }) => {
        console.error("Socket error:", err);
        setError(err.message);
        setIsLoading(false);
    });

    return () => {
      socket.off('update');
      socket.off('error');
    };
  }, []);
  
  // Effect to join the game room once we have a game ID
  useEffect(() => {
    if (gameState?.gameId) {
      socket.emit('join', { gameId: gameState.gameId });
    }
  }, [gameState?.gameId]);

  const newGame = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    setMessage(null);
    try {
      const response = await fetch(`${API_BASE_URL}/api/game`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ playerName: 'You' }),
      });
      if (!response.ok) throw new Error('Failed to start a new game.');
      const data: GameState = await response.json();
      handleApiResponse(data); // Set initial state
    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const handlePlayerAction = useCallback(async (action: PlayerAction, amount: number = 0) => {
    if (!gameState || gameState.activePlayerId !== 0) return;
    
    setIsLoading(true);
    setError(null);
    socket.emit('action', {
        gameId: gameState.gameId,
        playerId: 0,
        action,
        amount
    });
  }, [gameState]);
  
  const nextHand = useCallback(async () => {
    if (!gameState || isLoading) return;
    
    setIsLoading(true);
    setError(null);
    try {
        const response = await fetch(`${API_BASE_URL}/api/game/${gameState.gameId}/next`, {
            method: 'POST',
        });
        if (!response.ok) throw new Error('Failed to start the next hand.');
        const data: GameState = await response.json();
        handleApiResponse(data);
    } catch (err: any) {
        setError(err.message);
    } finally {
        setIsLoading(false);
    }
  }, [gameState, isLoading]);

  return { gameState, handlePlayerAction, newGame, nextHand, message, isLoading, error };
};


=========================================
FILE: ./texas-holdem-frontend/index.css
=========================================
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
    background-color: #111827; /* Darker bg */
    font-family: 'Inter', sans-serif;
    color: #f3f4f6;
}

/* Base style for pill-shaped buttons */
.pill-btn {
    @apply px-8 py-3 font-bold rounded-full shadow-lg transition-all duration-200 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100;
}

.btn-fold {
    @apply bg-gray-700 hover:bg-gray-800 text-gray-300 border-2 border-gray-900;
}

.btn-check {
    @apply bg-transparent hover:bg-gray-700 text-white border-2 border-gray-500;
}

.btn-call {
    @apply bg-blue-700 hover:bg-blue-800 text-white border-2 border-blue-900 hover:shadow-blue-500/50;
}

.btn-raise {
     @apply bg-green-600 hover:bg-green-700 text-white border-2 border-green-800 hover:shadow-green-500/50;
}


/* App title style to match the golden text in the image */
.app-title {
    color: #f59e0b; /* Amber 500 */
    text-shadow: 0 2px 10px rgba(245, 158, 11, 0.4);
    letter-spacing: 0.025em;
    font-weight: 800;
}


=========================================
FILE: ./texas-holdem-frontend/index.html
=========================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>Texas Hold'em</title>
    <script src="https://cdn.tailwindcss.com"></script>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-gray-900">
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>


=========================================
FILE: ./texas-holdem-frontend/index.tsx
=========================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


=========================================
FILE: ./texas-holdem-frontend/metadata.json
=========================================
{
  "name": "Texas Hold'em",
  "description": "A web-based Texas Hold'em poker game where a human player competes against three AI opponents powered by Gemini. This application provides a dynamic and modern user interface for the game.",
  "requestFramePermissions": []
}

=========================================
FILE: ./texas-holdem-frontend/package.json
=========================================
{
  "name": "texas-hold'em",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "framer-motion": "^12.23.22",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@vitejs/plugin-react": "^5.0.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}


=========================================
FILE: ./texas-holdem-frontend/styles/GameBoard.css
=========================================
.game-board {
    position: relative;
    width: 100%;
    max-width: 1200px;
    aspect-ratio: 16 / 9;
    margin: 0 auto; /* Center the board */
}

.table-wrapper {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 85%; /* Reduced slightly to give players more room outside */
    height: 80%;
    filter: drop-shadow(0 25px 50px -12px rgba(0, 0, 0, 0.6));
}

.poker-table {
    position: relative;
    width: 100%;
    height: 100%;
    border-radius: 300px;
    background: 
        radial-gradient(50% 50% at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 100%),
        radial-gradient(closest-side, #064e3b 0%, #022c22 100%);
    box-shadow: inset 0 0 60px rgba(0,0,0,0.8), 0 10px 30px rgba(0,0,0,0.5);
    border: 24px solid #3f2e18;
    border-image: linear-gradient(to bottom, #5c4025, #2e1e0f) 1;
}

/* Inner ring */
.poker-table::before {
    content: '';
    position: absolute;
    inset: 20px;
    border: 2px solid rgba(255,255,255,0.1);
    border-radius: 250px;
    pointer-events: none;
}

/* Center Logo */
.table-surface::after {
    content: 'TEXAS HOLD\'EM';
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Courier New', serif;
    font-weight: bold;
    font-size: clamp(1.5rem, 4vw, 3rem);
    color: rgba(0, 0, 0, 0.15);
    letter-spacing: 0.2em;
    pointer-events: none;
    white-space: nowrap;
}

.table-surface {
    position: absolute;
    inset: 0;
}

.card {
    background: white;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.4);
    border: 1px solid #d1d5db;
    transition: transform 0.2s;
}

/* Player Positions */
.player-position {
    position: absolute;
    width: 140px;
    z-index: 20;
    display: flex;
    justify-content: center;
}

/* Bottom (Human - Player 0) */
.player-pos-0-4 {
    bottom: -15%; 
    left: 50%;
    transform: translateX(-50%);
}

/* Left (Viper - Player 1) */
.player-pos-1-4 {
    top: 50%;
    left: -12%; /* Push further out */
    transform: translateY(-50%);
}

/* Top (Mountain - Player 2) */
.player-pos-2-4 {
    top: -20%; /* Push higher up */
    left: 50%;
    transform: translateX(-50%);
}

/* Right (Shark - Player 3) */
.player-pos-3-4 {
    top: 50%;
    right: -12%; /* Push further out */
    transform: translateY(-50%);
}

.player-pod {
    /* Lighter border and subtle gradient for better visibility against dark table */
    background: linear-gradient(180deg, rgba(31, 41, 55, 0.95) 0%, rgba(17, 24, 39, 1) 100%);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.15); /* More visible border */
    box-shadow: 
        0 4px 6px -1px rgba(0, 0, 0, 0.5), 
        0 2px 4px -1px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1); /* Top highlight */
    backdrop-filter: blur(4px);
}

.active-ring {
    box-shadow: 0 0 0 2px #f59e0b, 0 0 20px rgba(245, 158, 11, 0.6);
    border-color: #f59e0b;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 2px #f59e0b, 0 0 15px rgba(245, 158, 11, 0.5); }
    50% { box-shadow: 0 0 0 2px #fcd34d, 0 0 25px rgba(251, 191, 36, 0.8); }
    100% { box-shadow: 0 0 0 2px #f59e0b, 0 0 15px rgba(245, 158, 11, 0.5); }
}
    

=========================================
FILE: ./texas-holdem-frontend/tsconfig.json
=========================================
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}

=========================================
FILE: ./texas-holdem-frontend/types.ts
=========================================
export interface Player {
  id: number;
  name: string;
  chips: number;
  hand: string[];
  currentBet: number;
  isFolded: boolean;
  isHuman: boolean;
  isAllIn: boolean; // Also adding isAllIn from the backend
  lastAction?: string | null;
}

export type GameStage = 'PRE_FLOP' | 'FLOP' | 'TURN' | 'RIVER' | 'SHOWDOWN' | 'HAND_OVER';

export interface GameState {
  gameId: string;
  pot: number;
  communityCards: string[];
  activePlayerId: number | null;
  players: Player[];
  stage: GameStage;
  dealerId: number;
  smallBlindPlayerId: number;
  bigBlindPlayerId: number;
  betToCall: number;
  winners?: number[];
}

export type PlayerAction = 'fold' | 'check' | 'call' | 'bet' | 'raise';


=========================================
FILE: ./texas-holdem-frontend/vite.config.ts
=========================================
import path from 'path';
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// this is a backend-only key
export default defineConfig({
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
});


=========================================
FILE: ./texas-holdem-frontend/Dockerfile
=========================================
FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html

RUN echo 'server { \
    listen 80; \
    location / { \
        root /usr/share/nginx/html; \
        index index.html index.htm; \
        try_files $uri $uri/ /index.html; \
    } \
}' > /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

=========================================
FILE: ./context_dump.sh
=========================================
#!/bin/bash
# Optimized Scans the repo and dumps text files for LLM context

output="glashaus_context.txt"
echo "--- GLASHAUS PROJECT DUMP ---" > "$output"
date >> "$output"

# Define directories to completely ignore (folders)
IGNORE_DIRS="(node_modules|.next|.git|__pycache__|storage|logs|archive|.venv|venv|dist|build)"

# Define specific file names/extensions to ignore
IGNORE_FILES="(*.pyc|*.png|*.ico|*.jpg|*.svg|*.sqlite|*.lock|package-lock.json|bun.lockb|yarn.lock|.DS_Store)"

echo -e "\n\n--- GIT HISTORY ---" >> "$output"
git log --oneline --graph --decorate -n 20 >> "$output"

echo -e "\n\n--- FILE STRUCTURE ---" >> "$output"
# Uses the ignore pattern for tree
tree -L 3 -I "$IGNORE_DIRS|$IGNORE_FILES" >> "$output" 2>/dev/null

echo -e "\n\n--- FILE CONTENTS ---" >> "$output"

# The logic below uses -prune to skip entire directory trees efficiently
find . \
    -type d -regextype posix-extended -regex ".*/$IGNORE_DIRS" -prune -o \
    -type f \
    -not -name 'glashaus_context.txt' \
    -not -name '*.pyc' \
    -not -name '*.png' \
    -not -name '*.jpg' \
    -not -name '*.svg' \
    -not -name '*.sqlite' \
    -not -name 'package-lock.json' \
    -not -path './scraper_service.py' \
    -not -path './manual_session_audit.py' \
    -print | while read -r file; do
    
    # Skip files larger than 50KB (likely raw data dumps/logs)
    # except for the main schema or specific logic files
    filesize=$(wc -c <"$file")
    if [ $filesize -gt 50000 ] && [[ "$file" != *"schema"* ]]; then
        echo -e "\n\n[SKIPPING $file - TOO LARGE: $filesize bytes]" >> "$output"
        continue
    fi

    echo -e "\n\n=========================================" >> "$output"
    echo "FILE: $file" >> "$output"
    echo "=========================================" >> "$output"
    cat "$file" >> "$output"
done

echo "Dump complete. Size: $(du -h $output | cut -f1)"


=========================================
FILE: ./docker-compose.yml
=========================================
version: '3.8'

services:
  backend:
    build: ./texas-holdem-backend
    ports:
      - "5001:5001"
    env_file:
      - ./texas-holdem-backend/.env

  frontend:
    build: ./texas-holdem-frontend
    ports:
      - "3000:80"
    depends_on:
      - backend